#include <iostream>
#include <queue>

using namespace std;

/*************************************************************************************
 * 힙 (Heap)
 *
 * 부모 노드가 자식노드보다 우선순위가 높은 속성을 만족하는 트리기반의 자료구조
 * 많은 자료 중 우선순위가 가장 높은 요소를 빠르게 가져오기 위해 사용
 *************************************************************************************/

// <힙 구현>
// 힙은 노드들이 트리의 빈틈없이 채운 완전이진트리를 구조를 가지며
// 부모 노드가 두 자식노드보다 우선순위가 높은 값을 위치시킴
// 힙 상태를 만족하는 경우 가장 최상단 노드가 모든 노드 중 우선순위가 가장 높음
//
//               2
//       ┌───────┴───────┐
//       8               52
//   ┌───┴───┐       ┌───┴───┐
//   13      37      67      92
// ┌─┴─┐   ┌─┘
// 17  43  52


// <힙 노드 추가>
// 1. 힙의 최고 깊이, 마지막에 새 노드를 추가
//
//               2
//       ┌───────┴───────┐
//       8               52
//   ┌───┴───┐       ┌───┴───┐
//   13      37      67      92
// ┌─┴─┐   ┌─┴─┐
// 17  43  52 (7)
//
// 2. 추가한 노드와 부모 노드를 비교하여 우선순위가 더 높은 경우 교체
//
//               2                               2                               2
//       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
//       8               52              8               52             (7)              52
//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
//   13      37      67      92      13     (7)      67      92      13      8       67      92
// ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
// 17  43  52 (7)                  17  43  52  37                  17  43  52  37
//
// 3. 더이상 교체되지 않을때까지 과정을 반복
//
//               2                               2
//       ┌───────┴───────┐               ┌───────┴───────┐
//      (7)              52              7               52
//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
//   13      8       67      92      13      8       67      92
// ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐
// 17  43  52  37                  17  43  52  37


// <힙 노드 삭제>
// 1. 최상단의 노드와 마지막 노드를 교체한 뒤 마지막 노드를 삭제
//
//              (2)                             (37)                           (37)
//       ┌───────┴───────┐               ┌───────┴───────┐              ┌───────┴───────┐
//       7               52              7               52             7               52
//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>  ┌───┴───┐       ┌───┴───┐
//   13      8       67      92      13      8       67      92     13      8       67      92
// ┌─┴─┐   ┌─┴─┐                   ┌─┴─┐   ┌─┴─┐                  ┌─┴─┐   ┌─┘
// 17  43  52 (37)                 17  43  52 (2)                 17  43  52
//
// 2. 교체된 노드와 두 자식 노드를 비교하여 우선순위가 더 높은 노드와 교체
//
//              (37)                             7                               7
//       ┌───────┴───────┐               ┌───────┴───────┐               ┌───────┴───────┐
//       7               52             (37)             52              8               52
//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
//   13      8       67      92      13      8       67      92      13     (37)     67      92
// ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
// 17  43  52                      17  43  52                      17  43  52
//
// 3. 더이상 교체되지 않을때까지 과정을 반복
//
//               7                               7
//       ┌───────┴───────┐               ┌───────┴───────┐
//       8               52              8               52
//   ┌───┴───┐       ┌───┴───┐  =>   ┌───┴───┐       ┌───┴───┐
//   13     (37)     67      92      13      37      67      92
// ┌─┴─┐   ┌─┘                     ┌─┴─┐   ┌─┘
// 17  43  52                      17  43  52


// <힙 구현>
// 힙의 완전이진트리 특징의 경우 배열을 통해서 구현하기 좋음
// 노드의 위치를 배열에 순서대로 저장
// 노드가 위치한 인덱스에 연산을 진행하여 노드 이동이 가능
// 
// 부모로 이동         : (index - 1) / 2
// 왼쪽자식으로 이동   : 2 * index + 1
// 오른쪽자식으로 이동 : 2 * index + 2
//
//        0
//    ┌───┴───┐
//    1       2       ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
//  ┌─┴─┐   ┌─┴─┐ =>  │0│1│2│3│4│5│6│7│8│9│
//  3   4   5   6     └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
// ┌┴┐ ┌┘
// 7 8 9


int main()
{
    // 입력순서와 무관하게 데이터의 우선순위가 높은 순서부터 출력
    priority_queue<int> pq = priority_queue<int>();

    pq.push(5);
    pq.push(1);
    pq.push(3);
    pq.push(4);
    pq.push(2);

    cout << "priotiry queue" << endl;
    while (!pq.empty())
    {
        cout << pq.top() << endl;   // 출력순서 : 5, 4, 3, 2, 1
        pq.pop();
    }
    cout << endl;


    // 우선순위를 지정하기 위한 값과 데이터를 사용하는 방식
    priority_queue<pair<int, string>> pairPQ = priority_queue<pair<int, string>>();
    pairPQ.push(make_pair(5, "사과"));
    pairPQ.push(make_pair(1, "배"));
    pairPQ.push(make_pair(3, "감"));
    pairPQ.push(make_pair(4, "딸기"));
    pairPQ.push(make_pair(2, "포도"));

    cout << "pair priotiry queue" << endl;
    while (!pairPQ.empty())
    {
        cout << pairPQ.top().first << " : " << pairPQ.top().second << endl;
        pairPQ.pop();
    }
    cout << endl;
}
