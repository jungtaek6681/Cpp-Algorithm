#include <iostream>
#include <set>
#include <map>

using namespace std;

/******************************************************************
 * 이진탐색트리 (BinarySearchTree)
 *
 * 이진속성과 탐색속성을 적용한 트리
 * 이진탐색을 통한 탐색영역을 절반으로 줄여가며 탐색 가능
 * 이진 : 부모노드는 최대 2개의 자식노드를 가질 수 있음
 * 탐색 : 자신의 노드보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치
 *******************************************************************/

// <이진탐색트리 구현>
// 이진탐색트리는 모든 노드들이 최대 2개의 자식노드를 가질 수 있으며
// 자신의 노드보다 작은 값들은 왼쪽, 큰 값들은 오른쪽에 위치시킴
//
//             23
//      ┌──────┴──────┐
//      11            38
//   ┌──┴──┐       ┌──┴──┐
//   3     19      31    65
//   └─┐ ┌─┴─┐   ┌─┘     └─┐
//     6 17  22  24        87


// <이진탐색트리 탐색>
// 아래의 이진탐색트리에서 17 탐색
// 루트 노드부터 시작하여 탐색하는 값과 비교하여,
// 작은 경우 왼쪽자식노드로, 큰 경우 오른쪽자식노드를 탐색
//
//             23(↙)
//      ┌──────┴──────┐
//      11(↘)         38
//   ┌──┴──┐       ┌──┴──┐
//   3     19(↙)   31    65
//   └┐  ┌─┴─┐   ┌─┘
//    6 (17)  22  24


// <이진탐색트리 추가>
// 아래의 이진탐색트리에서 35 추가
// 루트 노드부터 시작하여 추가하는 값과 비교하여,
// 작은 경우 왼쪽자식노드로, 큰 경우 오른쪽자식노드로 하강
// 만약 빈공간이라면 빈공간에 추가
//
//             23(↘)                          23
//      ┌──────┴──────┐                ┌──────┴──────┐
//      11            38(↙)            11            38
//   ┌──┴──┐       ┌──┴──┐      =>  ┌──┴──┐       ┌──┴──┐ 
//   3     19      31(↘) 65         3     19      31    65
//   └─┐ ┌─┴─┐   ┌─┘                └─┐ ┌─┴─┐   ┌─┴─┐
//     6 17  22  24                   6 17  22  24 (35)


// <이진탐색트리 삭제>
// 1. 자식이 0개인 노드의 삭제 : 단순 삭제 진행
// 아래의 이진탐색트리에서 22 삭제
//
//             23                             23
//      ┌──────┴──────┐                ┌──────┴──────┐
//      11            38               11            38
//   ┌──┴──┐       ┌──┴──┐    =>    ┌──┴──┐       ┌──┴──┐
//   3     19      31    65         3     19      31    65
//   └─┐ ┌─┴─┐   ┌─┘                └─┐ ┌─┘     ┌─┴─┐
//     6 17 (22) 24                   6 17      24  35
//
// 2. 자식이 1개인 노드의 삭제 : 삭제하는 노드의 부모와 자식을 연결 후 삭제
// 아래의 이진탐색트리에서 38 삭제
//
//            23                              23
//     ┌──────┴──────┐                 ┌──────┴──────┐
//     11            (38)              11            31
//  ┌──┴──┐       ┌──┘        =>    ┌──┴──┐       ┌──┴──┐ 
//  3     19      31                3     19      24    35
//  └─┐ ┌─┴─┐   ┌─┴─┐               └─┐ ┌─┴─┐
//    6 17  22  24  35                6 17  22
//
// 3. 자식이 2개인 노드의 삭제 : 삭제하는 노드를 기준으로 오른쪽자식 중 가장 작은 값 노드와 교체 후 삭제
// 아래의 이진탐색트리에서 23 삭제
//
//           (23)                             24                              24
//     ┌──────┴──────┐                 ┌──────┴──────┐                 ┌──────┴──────┐
//     11            38                11            38                11            38
//  ┌──┴──┐       ┌──┴──┐     =>    ┌──┴──┐       ┌──┴──┐     =>    ┌──┴──┐       ┌──┴──┐ 
//  3     19      24    49          3     19     (23)   49          3     19      35   49
//  └─┐ ┌─┴─┐     └─┐               └─┐ ┌─┴─┐     └─┐               └─┐ ┌─┴─┐
//    6 17  22      35                6 17  22      35                6 17  22


// <이진탐색트리 정렬>
// 이진탐색트리는 중위순회시 오름차순으로 정렬됨
//
//             7
//      ┌──────┴──────┐
//      4             11
//   ┌──┴──┐       ┌──┴──┐
//   2     5       9     12
// ┌─┴─┐   └─┐   ┌─┴─┐
// 1   3     6   8   10
//
// 중위순회 : ((1, 2, 3), 4, (5, 6)), 7, ((8, 9, 10), 11, 12)
//            => 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12


// <이진탐색트리 주의점>
// 이진탐색트리는 최악의 상황에 노드들이 한쪽 자식으로만 추가되는 불균형 현상이 발생 가능
// 이 경우 탐색영역이 절반으로 줄여지지 않기 때문에 시간복잡도 증가
//
//           5
//         ┌─┘
//         4
//       ┌─┘
//       3
//     ┌─┘
//     2
//   ┌─┘
//   1
//
// 이러한 현상을 막기 위해 자가균형기능을 추가한 트리의 사용이 일반적
// 자가균형트리는 회전을 이용하여 불균형이 있는 상황을 해결
//
//       8                        5
//    ┌──┴──┐   -- 우회전 ->   ┌──┴──┐
//    5     9                  3     8
//  ┌─┴─┐       <- 좌회전 --       ┌─┴─┐      
//  3   6                          6   9 
//
// 대표적인 방식으로 Red-Black Tree, AVL Tree 등을 통해 불균형상황을 파악


int main()
{
    // set : 이진탐색트리 기반의 중복이 없는 정렬을 보장한 저장소
    set<int> valueContainer = set<int>();

    // 추가
    valueContainer.insert(5);
    valueContainer.insert(1);
    valueContainer.insert(2);
    valueContainer.insert(4);
    valueContainer.insert(3);
    valueContainer.insert(1);   // 중복 추가는 무시됨

    // 삭제
    valueContainer.erase(4);

    // 탐색
    valueContainer.find(3);

    // 순회시 정렬된 결과 확인
    cout << "Set iteration" << endl;
    for (const int& element : valueContainer)
    {
        cout << element << endl;    // output : 1, 2, 3, 5
    }
    cout << endl;


    // map : 이진탐색트리 기반의 중복이 없는 key를 기준으로 정렬을 보장한 value 저장소
    map<int, string> keyValueContainer = map<int, string>();

    // 추가
    keyValueContainer.insert(make_pair(4, "Beryllium"));
    keyValueContainer.insert(make_pair(2, "Helium"));
    keyValueContainer.insert(make_pair(1, "Hydrogen"));
    keyValueContainer.insert(make_pair(8, "Oxygen"));
    keyValueContainer.insert(make_pair(3, "Lithium"));

    // 삭제
    keyValueContainer.erase(8);

    // 탐색
    keyValueContainer.find(3);

    // 순회시 정렬된 결과 확인
    cout << "Map iteration" << endl;
    for (pair<int, string> element : keyValueContainer)
    {
        cout << element.first << " : " << element.second << endl;
    }
    cout << endl;

    // map의 간소화된 사용법
    // map의 경우 [] 연산자에 key 값을 이용하여 추가, 확인이 가능
    map<string, string> container = map<string, string>();
    container["key1"] = "value1";
    container["key2"] = "value2";
    container["key3"] = "value3";

    cout << "key1 : " << container["key1"] << endl;
    cout << "key2 : " << container["key2"] << endl;
    cout << "key3 : " << container["key3"] << endl;
    cout << "key4 : " << container["key4"] << endl;     // 없었던 요소의 경우 기본값
}
